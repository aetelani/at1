// This file is automatically generated by scxmlcc (version 0.9M-11)
// For more information, see http://scxmlcc.org

#ifndef __SC_FLOW
#define __SC_FLOW

#include <typeinfo>
#include <deque>
#include <vector>
#include <string>

class sc_flow
{
	public:

	struct data_model;
	struct user_model;

	class state
	{
		public:
		virtual ~state(){}
		virtual state* event_Exiting(sc_flow&) { return 0; }
		virtual state* event_Initiliazed(sc_flow&) { return 0; }
		virtual state* unconditional(sc_flow&) { return 0; }
		virtual state* initial(sc_flow&) { return 0; }

		template<class T> void enter(data_model&, ...) {}
		template<class T> void exit(data_model&, ...) {}
	};

	typedef state* (state::*event)(sc_flow&);

	template<class C> class state_actions
	{
		protected:
		void enter(data_model&) {} // default enter action
		void exit(data_model&) {} // default exit action
	};

	template<class C, class P> class composite : public P, public state_actions<C>
	{
		virtual state* initial(sc_flow&) { return 0; }
		public:
		typedef P parent_t;
		// LCA calculation
		template<class T> void enter(data_model&, composite*) {}
		template<class T> void enter(data_model &m, ...) { P::template enter<T>(m, (T*)0); state_actions<C>::enter(m); }
		template<class T> void exit(data_model&, composite*) {}
		template<class T> void exit(data_model &m, ...) { state_actions<C>::exit(m); P::template exit<T>(m, (T*)0); }
	};

	class no_state {};
	enum transition_type { external, internal };

	template<event E, class S, class D0 = no_state> class transition_actions
	{
		protected:
		void enter(data_model&) {} // default enter action
		bool condition(data_model&) { return true; } // default condition action
	};

	// external/internal transition
	template<event E, class S, class D = no_state, transition_type T = external> class transition : public transition_actions<E, S, D>
	{
		template<transition_type I> struct id { };
		void state_enter(D* d, data_model &m, id<internal>, S*) { d->template enter<composite<S, typename S::parent_t> >(m); } // internal transition, where dst is descendant of src
		void state_enter(D* d, data_model &m, ...) { d->template enter<typename S::parent_t>(m); } // external transition, or dst is not descendant of src
		void state_exit(S*, data_model &, id<internal>, S*) {} // internal transition, where dst is descendant of src
		void state_exit(S* s, data_model &m, ...) { s->template exit<typename D::parent_t>(m); } // external transition, or dst is not descendant of src
		public:
		state* operator ()(S *s, sc_flow &sc)
		{
			if(!transition_actions<E, S, D>::condition(sc.model)) return 0;
			D *d = sc.new_state<D>();
			state_exit(s, sc.model, id<T>(), (typename D::parent_t*)0);
			transition_actions<E, S, D>::enter(sc.model);
			state_enter(d, sc.model, id<T>(), (typename D::parent_t*)0);
			return d;
		}
	};

	private: bool dispatch_event(event e)
	{
		state *next_state;
		if ((next_state = (model.cur_state->*e)(*this))) model.cur_state = next_state;
		return !!next_state;
	}

	public: void dispatch(event e = &state::unconditional)
	{
		bool cont = dispatch_event(e) || dispatch_event(&state::unconditional);
		while (cont) {
			if ((cont = dispatch_event(&state::initial)));
			else if ((cont = dispatch_event(&state::unconditional)));
			else if (model.event_queue.size()) cont = dispatch_event(model.event_queue.front()), model.event_queue.pop_front(), cont |= !model.event_queue.empty();
			else break;
		}
	}
	struct data_model
	{
		std::deque<event> event_queue;
		state *cur_state;
		template <class S> bool In() { return typeid(*cur_state) == typeid(S); }
		user_model *user;
		const std::string _sessionid;
		const std::string _name;
		data_model(user_model* user)
		: user(user)
		, _sessionid(std::to_string(reinterpret_cast<long long unsigned int>(this)))
		, _name("flow")
		{}
	} model;

	sc_flow(user_model *user = nullptr)
	: model(user)
	{
		model.cur_state = new_state<scxml>();
	}

	void init() { dispatch(&state::initial); }

	struct scxml : public composite<scxml, state>
	{
		state* initial(sc_flow&sc) { return transition<&state::initial, scxml, state_Init, internal>()(this, sc); }
	};

	struct state_Init : public composite<state_Init, scxml>
	{
		state* event_Initiliazed(sc_flow &sc) { return transition<&state::event_Initiliazed, state_Init, state_Running>()(this, sc); }
	};

	struct state_Running : public composite<state_Running, scxml>
	{
		state* event_Exiting(sc_flow &sc) { return transition<&state::event_Exiting, state_Running, state_Finalize>()(this, sc); }
	};

	struct state_Finalize : public composite<state_Finalize, scxml>
	{
	};

	template<class T> T* new_state()
	{
		static T t;
		return &t;
	}
};

#endif
